require_relative 'clock'

module Musa
  module Clock
    # Clock driven by external tick() calls for integration and testing.
    #
    # ExternalTickClock doesn't generate its own ticks. Instead, ticks are
    # triggered manually by calling the {#tick} method. This is useful for:
    # - Testing with precise control over timing
    # - Integration with external systems that provide timing
    # - Step-by-step debugging of sequencer logic
    # - Synchronization with non-realtime processes
    #
    # ## Operation
    #
    # 1. Call {#run} to initialize (doesn't block)
    # 2. Call {#tick} repeatedly to generate ticks
    # 3. Call {#terminate} when done
    #
    # ## Use Cases
    #
    # - Testing sequencer behavior step-by-step
    # - Integration with game engines or other event loops
    # - Offline rendering without realtime constraints
    # - Precise control for debugging
    #
    # @example Manual stepping
    #   clock = ExternalTickClock.new
    #   transport = Transport.new(clock)
    #   transport.start
    #
    #   # Later, from external source:
    #   clock.tick  # Advances one tick
    #   clock.tick  # Another tick
    #   # ... etc
    #
    # @example Integration with game loop
    #   clock = ExternalTickClock.new
    #   transport = Transport.new(clock)
    #   transport.start
    #
    #   # In game update loop:
    #   def update(delta_time)
    #     if should_tick?(delta_time)
    #       clock.tick
    #     end
    #   end
    #
    # @example Testing
    #   clock = ExternalTickClock.new
    #   transport = Transport.new(clock)
    #
    #   # Schedule some events
    #   transport.sequencer.at 0 { puts "Tick 0" }
    #   transport.sequencer.at 1 { puts "Tick 1" }
    #
    #   transport.start
    #   clock.tick  # => "Tick 0"
    #   clock.tick  # => "Tick 1"
    #
    # @see DummyClock For automatic testing with fixed tick counts
    class ExternalTickClock < Clock
      # Creates a new externally-controlled clock.
      #
      # @param do_log [Boolean, nil] enable logging
      def initialize(do_log: nil)
        do_log ||= false

        super()

        @do_log = do_log
      end

      # Initializes the clock (non-blocking).
      #
      # Unlike other clocks, this method doesn't block. It stores the block
      # and calls on_start callbacks, then returns immediately. Ticks are
      # generated by calling {#tick}.
      #
      # @yield Called for each tick triggered by {#tick}
      # @return [void]
      #
      # @note This method does NOT block
      def run(&block)
        @on_start.each(&:call)
        @run = true
        @block = block
      end

      # Generates one tick manually.
      #
      # If the clock is running, calls the registered block (typically
      # sequencer.tick). Has no effect if clock is not running.
      #
      # @return [void]
      #
      # @note Only works if {#run} has been called
      # @note Thread-safe for integration with external event loops
      def tick
        if @run
          @block.call if @block
        end
      end

      # Terminates the clock and calls on_stop callbacks.
      #
      # @return [void]
      def terminate
        @on_stop.each(&:call)
        @run = false
      end
    end
  end
end
