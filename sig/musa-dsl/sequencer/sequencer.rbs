# RBS for sequencer/base-sequencer.rb - Musical sequencer and scheduler

module Musa
  module Sequencer
    # Musical sequencer and scheduler system.
    class BaseSequencer
      # Beats per bar (tick-based mode only).
      attr_reader beats_per_bar: Rational?

      # Ticks per beat (tick-based mode only).
      attr_reader ticks_per_beat: Rational?

      # Time offset for position calculations.
      attr_reader offset: Rational

      # Current running position.
      attr_reader running_position: Rational

      # Active every loops.
      attr_reader everying: Array[EveryControl]

      # Active play operations.
      attr_reader playing: Array[PlayControl | PlayTimedControl]

      # Active move operations.
      attr_reader moving: Array[MoveControl]

      # Sequencer logger.
      attr_reader logger: untyped

      # Creates sequencer with timing configuration.
      def initialize: (
        ?Numeric? beats_per_bar,
        ?Numeric? ticks_per_beat,
        ?offset: Rational?,
        ?logger: untyped?,
        ?do_log: bool?,
        ?do_error_log: bool?,
        ?log_position_format: Proc?
      ) -> void

      # Resets sequencer to initial state.
      def reset: () -> void

      # Counts total scheduled events.
      def size: () -> Integer

      # Checks if sequencer has no scheduled events.
      def empty?: () -> bool

      # Current position.
      def position: () -> Rational

      # Sets position (triggers fast-forward).
      def position=: (Rational position) -> Rational

      # Duration of one tick.
      def tick_duration: () -> Rational

      # Quantizes position to tick grid.
      def quantize_position: (Rational position, ?warn: bool?) -> Rational

      # Advances sequencer by one tick.
      def tick: () -> void

      # Executes all scheduled events until empty.
      def run: () -> void

      # Registers debug callback.
      def on_debug_at: () { () -> void } -> void

      # Registers error callback.
      def on_error: () { (StandardError | ScriptError) -> void } -> void

      # Registers fast-forward callback.
      def on_fast_forward: () { (bool) -> void } -> void

      # Registers before-tick callback.
      def before_tick: () { (Rational) -> void } -> void

      # Subscribes to custom event.
      def on: (Symbol event) { (*untyped, **untyped) -> void } -> void

      # Launches custom event.
      def launch: (Symbol event, *untyped value_parameters, **untyped key_parameters) -> void

      # Schedules block relative to current position.
      def wait: (Numeric | Musa::Series::_SerieProtocol | Array[Numeric] bars_delay, ?debug: bool?) { (?control: EventHandler) -> void } -> EventHandler

      # Schedules block at current position.
      def now: () { (?control: EventHandler) -> void } -> EventHandler

      # Schedules block at absolute position (low-level).
      def raw_at: (Numeric bar_position, ?force_first: bool?) { () -> void } -> nil

      # Schedules block at absolute position.
      def at: (Numeric | Musa::Series::_SerieProtocol | Array[Numeric] bar_position, ?debug: bool?) { (?control: EventHandler) -> void } -> EventHandler

      # Plays series over time.
      def play: (
        Musa::Series::_SerieProtocol serie,
        ?mode: Symbol?,
        ?parameter: Symbol?,
        ?after_bars: Numeric?,
        ?after: Proc?,
        ?context: untyped?,
        **untyped mode_args
      ) { (*untyped, **untyped) -> void } -> PlayControl

      # Plays timed series.
      def play_timed: (
        Musa::Series::_SerieProtocol timed_serie,
        ?at: Rational?,
        ?on_stop: Proc?,
        ?after_bars: Numeric?,
        ?after: Proc?
      ) { (untyped, time: Rational, started_ago: Hash[untyped, Rational], control: PlayTimedControl) -> void } -> PlayTimedControl

      # Executes block repeatedly at regular intervals.
      def every: (
        Numeric? interval,
        ?duration: Numeric?,
        ?till: Numeric?,
        ?condition: Proc?,
        ?on_stop: Proc?,
        ?after_bars: Numeric?,
        ?after: Proc?
      ) { (?control: EveryControl) -> void } -> EveryControl

      # Animates value from start to end over time.
      def move: (
        ?every: Numeric?,
        ?from: Numeric | Array[Numeric] | Hash[Symbol, Numeric]?,
        ?to: Numeric | Array[Numeric] | Hash[Symbol, Numeric]?,
        ?step: Numeric?,
        ?duration: Numeric?,
        ?till: Numeric?,
        ?function: (Symbol | Proc)?,
        ?right_open: bool?,
        ?on_stop: Proc?,
        ?after_bars: Numeric?,
        ?after: Proc?
      ) { (Numeric | Array[Numeric] | Hash[Symbol, Numeric]) -> void } -> MoveControl

      def debug: (?String? msg) -> void
      def to_s: () -> String
    end

    # Event handler for hierarchical event pub/sub.
    class EventHandler
      def initialize: (?EventHandler? parent) -> void

      # Subscribes to event.
      def on: (Symbol event) { (*untyped, **untyped) -> void } -> void

      # Launches event.
      def launch: (Symbol event, *untyped value_parameters, **untyped key_parameters) -> void

      # Stops the control.
      def stop: () -> void

      # Checks if stopped.
      def stopped?: () -> bool
    end

    # Control object for every loops.
    class EveryControl < EventHandler
      def initialize: (
        EventHandler parent,
        ?duration: Numeric?,
        ?till: Numeric?,
        ?condition: Proc?,
        ?on_stop: Proc?,
        ?after_bars: Numeric?,
        ?after: Proc?
      ) -> void

      # Registers after callback.
      def after: (?Numeric? bars) { () -> void } -> void

      # Registers on_stop callback.
      def on_stop: () { () -> void } -> void

      # Start position.
      attr_reader start_position: Rational

      # Current iteration counter.
      attr_reader counter: Integer
    end

    # Control object for play operations.
    class PlayControl < EventHandler
      def initialize: (EventHandler parent, ?after_bars: Numeric?, ?after: Proc?) -> void

      # Registers after callback.
      def after: (?Numeric? bars) { () -> void } -> void

      # Registers on_stop callback.
      def on_stop: () { () -> void } -> void

      # Pauses playback.
      def pause: () -> void

      # Continues playback.
      def continue: () -> void

      # Checks if paused.
      def paused?: () -> bool
    end

    # Control object for timed play operations.
    class PlayTimedControl < EventHandler
      def initialize: (
        EventHandler parent,
        ?on_stop: Proc?,
        ?after_bars: Numeric?,
        ?after: Proc?
      ) -> void

      # Registers after callback.
      def after: (?Numeric? bars) { () -> void } -> void

      # Registers on_stop callback.
      def on_stop: () { () -> void } -> void

      # Start position.
      attr_reader start_position: Rational
    end

    # Control object for move operations.
    class MoveControl < EventHandler
      def initialize: (
        EventHandler parent,
        ?on_stop: Proc?,
        ?after_bars: Numeric?,
        ?after: Proc?
      ) -> void

      # Registers after callback.
      def after: (?Numeric? bars) { () -> void } -> void

      # Registers on_stop callback.
      def on_stop: () { () -> void } -> void
    end
  end
end
