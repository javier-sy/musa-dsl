# RBS for midi/midi-voices.rb - MIDI channel management synchronized with sequencer

module Musa
  module MIDIVoices
    # High level helpers to drive MIDI channels from a sequencer.
    class MIDIVoices
      # Whether verbose logging is enabled.
      attr_accessor do_log: bool

      # Builds the voice container for MIDI channels.
      def initialize: (
        sequencer: Sequencer::BaseSequencer,
        output: untyped,
        channels: (Array[Integer] | Range[Integer] | Integer),
        ?do_log: bool?
      ) -> void

      # Resets the collection recreating every voice.
      def reset: () -> void

      # Read-only list of per-channel voices.
      attr_reader voices: Array[MIDIVoice]

      # Enables or disables fast-forward mode on every voice.
      def fast_forward=: (bool enabled) -> void

      # Sends all-notes-off on every channel.
      def panic: (?reset: bool?) -> void
    end

    # Individual MIDI channel voice with sequencer-synchronized note management.
    class MIDIVoice
      # Optional name used in log messages.
      attr_accessor name: String?

      # Whether this voice logs every emitted message.
      attr_accessor do_log: bool

      # Sequencer driving this voice.
      attr_reader sequencer: Sequencer::BaseSequencer

      # MIDI destination.
      attr_reader output: untyped

      # MIDI channel number (0-15).
      attr_reader channel: Integer

      # Metadata for each of the 128 MIDI pitches.
      attr_reader active_pitches: Array[Hash[Symbol, untyped]]

      # Duration in bars of a sequencer tick.
      attr_reader tick_duration: Rational

      def initialize: (
        sequencer: Sequencer::BaseSequencer,
        output: untyped,
        channel: Integer,
        ?name: String?,
        ?do_log: bool?
      ) -> void

      # Turns fast-forward on/off for this voice.
      def fast_forward=: (bool enabled) -> void

      # Whether in fast-forward mode.
      def fast_forward?: () -> bool

      # Plays one or several MIDI notes.
      def note: (
        ?Integer? pitchvalue,
        ?pitch: (Integer | Symbol | Array[Integer | Symbol])?,
        ?velocity: (Integer | Array[Integer])?,
        ?duration: Numeric?,
        ?duration_offset: Numeric?,
        ?note_duration: Numeric?,
        ?velocity_off: (Integer | Array[Integer])?
      ) -> NoteControl?

      # MIDI CC manager for this voice.
      def controller: () -> untyped

      # Sets the sustain pedal state.
      def sustain_pedal=: (Integer value) -> Integer

      # Current sustain pedal value.
      def sustain_pedal: () -> Integer?

      # Sends all-notes-off message on this channel.
      def all_notes_off: () -> void

      # Logs a message tagging the current voice.
      def log: (String msg) -> void

      def to_s: () -> String
    end

    # Note lifecycle controller.
    class NoteControl
      # Voice that scheduled this control.
      attr_reader voice: MIDIVoice

      # MIDI note numbers handled by the control.
      attr_reader pitch: Array[Integer | Symbol]

      # Per-note on velocities.
      attr_reader velocity: Array[Integer]

      # Per-note off velocities.
      attr_reader velocity_off: Array[Integer]

      # Duration in bars or nil for indefinite notes.
      attr_reader duration: Numeric?

      # Sequencer position at which the note began.
      attr_reader start_position: Rational?

      # Sequencer position of the note-off.
      attr_reader end_position: Rational?

      def initialize: (
        MIDIVoice voice,
        pitch: (Integer | Symbol | Array[Integer | Symbol]),
        ?velocity: (Integer | Array[Integer])?,
        ?duration: Numeric?,
        ?velocity_off: (Integer | Array[Integer])?
      ) -> void

      # Emits the NoteOn messages and schedules note-off.
      def note_on: () -> NoteControl

      # Stops the note.
      def note_off: (?velocity: (Integer | Array[Integer])?) -> void

      # Whether the note is sounding.
      def active?: () -> bool

      # Registers a block to be executed when the note stops.
      def on_stop: () { () -> void } -> void

      # Registers a block to be executed after the note has ended.
      def after: (?Numeric bars) { () -> void } -> void
    end
  end
end
